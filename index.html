<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloudflare Worker IPTV 播放器</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Video.js for the player UI -->
    <link href="https://vjs.zencdn.net/8.5.2/video-js.css" rel="stylesheet" />
    <script src="https://vjs.zencdn.net/8.5.2/video.min.js"></script>
    
    <!-- Hls.js for native M3U8 playback in more browsers -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.10"></script>
    
    <style>
        /* Custom styles for dark theme and layout */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #0d1117; /* Dark BG */
            color: #c9d1d9; /* Light text */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
        }
        #app-container { 
            max-width: 1400px;
            width: 100%;
            display: flex;
            flex-direction: row;
            padding: 1rem;
        }
        .video-js { 
            width: 100%; 
            height: 100%; 
            border-radius: 0.5rem;
        }
        #channel-list { 
            min-width: 250px; 
            background-color: #161b22; 
            border-radius: 0.5rem; 
            overflow-y: auto; 
            max-height: calc(100vh - 8rem); 
            margin-right: 1rem;
        }
        #channels {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #channels li a {
            display: block;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #21262d;
            text-decoration: none;
            color: #c9d1d9;
            transition: background-color 0.2s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #channels li a:hover {
            background-color: #30363d;
        }
        #channels li a.active {
            background-color: #007acc; /* Blue highlight */
            color: white;
            font-weight: bold;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
                padding: 0.5rem;
            }
            #channel-list {
                max-height: 40vh; 
                width: 100%;
                margin-right: 0;
                margin-bottom: 0.5rem;
            }
            #player-container {
                width: 100%;
                min-height: 50vh;
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- 应用容器 -->
    <div id="app-container" class="flex flex-col lg:flex-row w-full p-4">

        <!-- 频道列表 (左侧/顶部) -->
        <aside id="channel-list" class="p-3 lg:w-1/4 flex-shrink-0">
            <h2 class="text-xl font-bold mb-3 text-white">频道列表</h2>
            <ul id="channels" class="text-sm">
                <p class="p-2 text-gray-500">请先输入 URL 并加载。</p>
            </ul>
        </aside>

        <!-- 播放器区域 (右侧/底部) -->
        <section id="player-container" class="lg:w-3/4 w-full flex flex-col space-y-4">
            
            <!-- URL 输入和加载按钮 -->
            <header class="bg-[#161b22] p-4 rounded-lg shadow-md">
                <h1 class="text-2xl font-extrabold text-white mb-3">IPTV 播放器</h1>
                <div id="url-input-area" class="flex flex-col gap-3">
                    <!-- 输入框 -->
                    <input 
                        type="url" 
                        id="iptv-url" 
                        placeholder="输入 M3U 订阅链接或单个流地址" 
                        value="" 
                        class="flex-grow p-2.5 rounded-lg bg-[#0d1117] border border-[#30363d] text-white focus:ring-blue-500 focus:border-blue-500"
                    />

                    <!-- 按钮和开关 -->
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <!-- Worker 开关 -->
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="use-proxy" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="use-proxy" class="text-sm text-gray-300 select-none">使用 Worker 代理 (解决 CORS/相对路径)</label>
                        </div>

                        <!-- 按钮组 -->
                        <div class="flex gap-2">
                            <button 
                                id="load-playlist" 
                                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200"
                            >
                                加载 M3U 列表
                            </button>
                            <button 
                                id="direct-play" 
                                class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200"
                            >
                                直链播放
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-3 text-sm h-5">
                    <span id="status-message" class="text-yellow-500">等待输入...</span>
                </div>
            </header>

            <!-- 视频播放器 -->
            <div class="flex-grow bg-[#161b22] rounded-lg p-1.5 shadow-xl relative min-h-[300px]">
                <video 
                    id="tv-player" 
                    class="video-js vjs-default-skin w-full h-full rounded-md" 
                    controls 
                    preload="auto" 
                    poster="https://placehold.co/1280x720/161b22/c9d1d9?text=IPTV+Stream"
                >
                    <p class="vjs-no-js">
                        要查看此视频，请启用 JavaScript，并考虑升级到支持 HTML5 视频的浏览器。
                    </p>
                </video>
            </div>
        </section>
    </div>

    <!-- JavaScript Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const iptvUrlInput = document.getElementById('iptv-url');
            const loadButton = document.getElementById('load-playlist');
            const directPlayButton = document.getElementById('direct-play'); // 直链播放按钮
            const useProxyCheckbox = document.getElementById('use-proxy'); // Worker 开关
            const channelListUl = document.getElementById('channels');
            const statusMessage = document.getElementById('status-message');
            const videoElement = document.getElementById('tv-player');
            
            // 初始化 Video.js 播放器
            const player = videojs(videoElement, {
                 autoplay: true,
                 muted: true, // 初始静音以规避浏览器自动播放限制
                 controls: true,
            });

            // ==========================================================
            // !!! 关键配置: Cloudflare Worker 代理地址 !!!
            // ==========================================================
            // 确保这里是您的 Worker 的 HTTPS 地址，末尾包含斜杠 "/"。
            const WORKER_PROXY_BASE_URL = 'https://m3u.521986.xyz/'; 

            /**
             * 更新状态信息
             */
            function updateStatus(message, type = 'info') {
                statusMessage.textContent = message;
                statusMessage.style.color = {
                    'info': '#fcd34d', 
                    'error': '#f87171', 
                    'success': '#4ade80' 
                }[type] || '#fcd34d';
            }

            /**
             * 检查是否启用 Worker 代理
             */
            function isProxyEnabled() {
                return useProxyCheckbox.checked;
            }

            /**
             * ⭐ 核心修复：清理用户输入的 URL，防止双重代理 ⭐
             */
/**
 * ⭐ 核心修复：清理用户输入的 URL，防止双重代理 ⭐
 */
/**
 * ⭐ 核心修复：清理用户输入的 URL，防止双重代理 ⭐
 */
function cleanInputUrl(url) {
    // 如果未启用 Worker 代理，直接返回
    if (!isProxyEnabled()) {
        return url;
    }

    try {
        // 检查输入的 URL 是否已经指向 Worker 代理或其他代理
        if (url.startsWith(WORKER_PROXY_BASE_URL) || 
            url.includes('?url=') || 
            url.includes('%3Furl%3D')) {
            
            console.log("Input contains proxy pattern. Attempting to extract original URL.");
            
            let currentUrl = url;
            let depth = 0;
            const maxDepth = 5; // 防止无限循环
            
            // 递归提取原始URL
            while (depth < maxDepth) {
                try {
                    const urlObj = new URL(currentUrl);
                    
                    if (urlObj.searchParams.has('url')) {
                        const extractedUrl = urlObj.searchParams.get('url');
                        if (extractedUrl) {
                            currentUrl = decodeURIComponent(extractedUrl);
                            depth++;
                            continue;
                        }
                    }
                    break;
                    
                } catch (e) {
                    break;
                }
            }
            
            return currentUrl;
        }
        
    } catch (e) {
        console.error("Error cleaning input URL:", e);
    }
    
    return url;
}
            /**
             * 将原始 URL 转换为 Worker 代理 URL 或返回原始 URL (取决于开关)
             */
            function getProcessedUrl(url) {
                if (isProxyEnabled() && WORKER_PROXY_BASE_URL) {
                    // 对 M3U/M3U8 链接进行编码，然后通过 Worker 代理
                    return `${WORKER_PROXY_BASE_URL}?url=${encodeURIComponent(url)}`;
                }
                // 返回原始链接 (直链或 Worker 禁用)
                return url;
            }

            /**
             * 获取 M3U 文件内容 (使用或不使用 Worker 代理)
             */
            async function fetchM3UContent(rawUrl) {
                // 先清理 URL，防止双重代理
                const cleanUrl = cleanInputUrl(rawUrl);
                
                // 根据开关决定最终请求的 URL
                const finalUrl = getProcessedUrl(cleanUrl);
                
                const proxyMessage = isProxyEnabled() ? '通过 Worker 代理' : '直连';
                updateStatus(`正在${proxyMessage}加载 M3U 列表: ${cleanUrl.substring(0, 50)}...`, 'info');

                try {
                    const response = await fetch(finalUrl);

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`网络错误或源站超时: ${response.status} ${response.statusText}. 响应: ${errorText}`);
                    }

                    const text = await response.text();
                    updateStatus('M3U 列表加载成功，正在解析。', 'success');
                    return { content: text, baseUrl: cleanUrl }; // 返回原始 M3U 链接作为解析相对路径的基准

                } catch (error) {
                    if (error.message.includes('522') && isProxyEnabled()) {
                         updateStatus('错误 (522): Worker 递归调用或连接超时。请尝试关闭 Worker 代理。', 'error');
                    } else if (error.message.includes('CORS')) {
                         updateStatus('错误 (CORS): 无法获取 M3U 内容。请尝试开启 Worker 代理。', 'error');
                    } else {
                         updateStatus(`加载 M3U 失败: ${error.message}`, 'error');
                    }
                    console.error('Fetch M3U Error:', error);
                    return null;
                }
            }

            /**
             * 解析 M3U 文件内容
             */
            function parseM3U(content) {
                // ... (解析逻辑不变)
                const lines = content.split('\n');
                const channels = [];
                let currentChannel = {};

                for (const line of lines) {
                    if (line.startsWith('#EXTINF:')) {
                        const match = line.match(/,(.+)$/);
                        if (match && match[1]) {
                            currentChannel.name = match[1].trim();
                        }
                    } else if (line.trim().length > 0 && !line.startsWith('#')) {
                        currentChannel.url = line.trim();
                        if (currentChannel.name && currentChannel.url) {
                            channels.push({ ...currentChannel });
                        }
                        currentChannel = {}; 
                    }
                }
                return channels;
            }

            /**
             * 渲染频道列表
             */
            function renderChannels(channels) {
                // ... (渲染逻辑不变)
                channelListUl.innerHTML = '';
                channels.forEach((channel, index) => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = channel.name;
                    a.setAttribute('data-url', channel.url);
                    a.setAttribute('data-name', channel.name);
                    a.onclick = (e) => {
                        e.preventDefault();
                        playChannel(channel.url, channel.name, index);
                        
                        document.querySelectorAll('#channels li a').forEach(el => {
                            el.classList.remove('active');
                        });
                        a.classList.add('active');
                        
                        // 保存当前播放的流的原始 URL (用于恢复会话)
                        localStorage.setItem('currentStreamUrl', channel.url);
                    };
                    li.appendChild(a);
                    li.classList.add('rounded-lg');
                    channelListUl.appendChild(li);
                });
            }

            /**
             * 播放指定的频道 (使用或不使用 Worker 代理)
             */
            function playChannel(rawUrl, name, index) {
                player.pause(); 
                
                // ⭐ 核心：根据 Worker 开关决定播放 URL ⭐
                // 如果启用了 Worker， getProcessedUrl 会返回代理链接，由 Worker 解决 CORS 和相对路径
                // 如果禁用 Worker， getProcessedUrl 会返回原始链接
                const url = getProcessedUrl(rawUrl); 

                const proxyStatus = isProxyEnabled() ? ' (通过 Worker)' : ' (直连)';
                updateStatus(`频道播放中: ${name}${proxyStatus}`, 'success');

                // Hls.js 播放逻辑 (推荐使用 Hls.js 以获取更好的兼容性)
                if (Hls.isSupported()) {
                    // 必须先销毁旧的 Hls.js 实例
                    if (player.hls) {
                        player.hls.destroy();
                    }
                    
                    const hls = new Hls();
                    player.hls = hls; // 存储实例以便后续销毁
                    
                    hls.loadSource(url);
                    hls.attachMedia(videoElement);

                    hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        player.play().catch(e => {
                            player.muted(false); // 取消静音后重试
                            player.play().catch(err => {
                                console.log("Player autplay blocked:", err);
                                updateStatus(`播放失败: ${name} (需要用户手动点击播放)`, 'error');
                            });
                        });
                    });
                    hls.on(Hls.Events.ERROR, function (event, data) {
                        if (data.fatal) {
                            // ... 错误处理逻辑 (不变)
                            updateStatus(`播放错误: ${name}. ${data.reason} (${isProxyEnabled() ? 'Proxy On' : 'Proxy Off'})`, 'error');
                        }
                    });
                } 
                // Video.js 原生/浏览器原生 HLS 逻辑 (适用于 Safari/Edge)
                else if (videoElement.canPlayType('application/vnd.apple.mpegurl') || videoElement.canPlayType('application/x-mpegURL')) {
                    player.src({
                        src: url,
                        type: 'application/x-mpegURL'
                    });
                    player.load();
                    player.play().catch(e => console.log("Player autplay blocked:", e));
                } 
                // 都不支持
                else {
                    updateStatus('错误: 您的浏览器不支持 HLS/M3U8 流播放。', 'error');
                }
            }

            // ==========================================================
            // 事件监听器
            // ==========================================================

            // 1. 加载 M3U 列表
            loadButton.addEventListener('click', async () => {
                const m3uInput = iptvUrlInput.value.trim();
                if (!m3uInput) {
                    updateStatus('请输入 M3U 订阅链接！', 'error');
                    return;
                }

                // 保存用户输入的 URL (清理后的)
                const m3uUrl = cleanInputUrl(m3uInput);
                localStorage.setItem('iptvUrl', m3uUrl);
                localStorage.removeItem('currentStreamUrl'); // 清除直链模式记录
                localStorage.setItem('useProxy', isProxyEnabled()); // 记录代理开关状态

                const m3uResult = await fetchM3UContent(m3uUrl);
                
                if (m3uResult) {
                    const channels = parseM3U(m3uResult.content);
                    renderChannels(channels);
                    
                    if (channels.length > 0) {
                        // 默认播放第一个频道
                        setTimeout(() => {
                            document.querySelector('#channels li a')?.click();
                        }, 50); 
                    } else {
                         updateStatus('M3U 文件已加载，但未找到任何频道。', 'error');
                    }
                }
            });

            // 2. 直链播放
            directPlayButton.addEventListener('click', () => {
                const streamUrl = iptvUrlInput.value.trim();
                if (!streamUrl) {
                    updateStatus('请输入有效的流地址进行直链播放！', 'error');
                    return;
                }
                
                // 清空频道列表
                channelListUl.innerHTML = `<p class="p-2 text-gray-500">当前为直链播放模式。</p>`;
                
                // 保存当前直链 URL 和代理状态
                localStorage.setItem('iptvUrl', streamUrl); // 统一使用 iptvUrl 存储上次使用的 URL
                localStorage.setItem('currentStreamUrl', streamUrl); // 记录当前播放的流
                localStorage.setItem('useProxy', isProxyEnabled()); // 记录代理开关状态

                const streamName = `直链流 (${streamUrl.substring(0, 40)}...)`;

                playChannel(streamUrl, streamName);
            });
            
            // 3. 初始加载逻辑
            const storedUrl = localStorage.getItem('iptvUrl');
            const storedStreamUrl = localStorage.getItem('currentStreamUrl');
            const storedProxy = localStorage.getItem('useProxy') === 'true';

            // 恢复代理开关状态
            useProxyCheckbox.checked = storedProxy;

            if (storedUrl) {
                iptvUrlInput.value = storedUrl;
                updateStatus('检测到上次会话记录，正在加载...', 'info');
                
                // 检查是 M3U 列表模式还是直链模式
                if (storedStreamUrl && storedUrl === storedStreamUrl) {
                    // 如果上次是直链播放，恢复直链模式
                    directPlayButton.click();
                } else {
                    // 如果上次是 M3U 列表模式，恢复 M3U 列表模式
                    loadButton.click(); 
                }
            } else {
                 updateStatus('请输入 M3U 订阅链接或流地址。', 'info');
            }
        });
    </script>
</body>
</html>


