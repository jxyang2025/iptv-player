<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloudflare Worker IPTV 播放器</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Video.js for the player UI -->
    <link href="https://vjs.zencdn.net/8.5.2/video-js.css" rel="stylesheet" />
    <script src="https://vjs.zencdn.net/8.5.2/video.min.js"></script>
    
    <!-- Hls.js for native M3U8 playback in more browsers -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.10"></script>
    
    <style>
        /* Custom styles for dark theme and layout */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #0d1117; /* Dark BG */
            color: #c9d1d9; /* Light text */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
        }
        #app-container { 
            max-width: 1400px;
            width: 100%;
            display: flex;
            flex-direction: row;
            padding: 1rem;
        }
        .video-js { 
            width: 100%; 
            height: 100%; 
            border-radius: 0.5rem;
        }
        #channel-list { 
            min-width: 250px; 
            background-color: #161b22; 
            border-radius: 0.5rem; 
            overflow-y: auto; 
            max-height: calc(100vh - 8rem); 
            margin-right: 1rem;
        }
        #channels {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #channels li a {
            display: block;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #21262d;
            text-decoration: none;
            color: #c9d1d9;
            transition: background-color 0.2s;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #channels li a:hover {
            background-color: #30363d;
        }
        #channels li a.active {
            background-color: #007acc; /* Blue highlight */
            color: white;
            font-weight: bold;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
                padding: 0.5rem;
            }
            #channel-list {
                max-height: 40vh; 
                width: 100%;
                margin-right: 0;
                margin-bottom: 0.5rem;
            }
            #player-container {
                width: 100%;
                min-height: 50vh;
            }
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- 应用容器 -->
    <div id="app-container" class="flex flex-col lg:flex-row w-full p-4">

        <!-- 频道列表 (左侧/顶部) -->
        <aside id="channel-list" class="p-3 lg:w-1/4 flex-shrink-0">
            <h2 class="text-xl font-bold mb-3 text-white">频道列表</h2>
            <ul id="channels" class="text-sm">
                <p class="p-2 text-gray-500">请先输入 URL 并加载。</p>
            </ul>
        </aside>

        <!-- 播放器区域 (右侧/底部) -->
        <section id="player-container" class="lg:w-3/4 w-full flex flex-col space-y-4">
            
            <!-- URL 输入和加载按钮 -->
            <header class="bg-[#161b22] p-4 rounded-lg shadow-md">
                <h1 class="text-2xl font-extrabold text-white mb-3">IPTV 播放器</h1>
                <div id="url-input-area" class="flex flex-col gap-3">
                    <!-- 输入框 -->
                    <input 
                        type="url" 
                        id="iptv-url" 
                        placeholder="输入 M3U 订阅链接或单个流地址" 
                        value="" 
                        class="flex-grow p-2.5 rounded-lg bg-[#0d1117] border border-[#30363d] text-white focus:ring-blue-500 focus:border-blue-500"
                    />

                    <!-- 按钮和开关 -->
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <!-- Worker 开关 -->
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="use-proxy" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <label for="use-proxy" class="text-sm text-gray-300 select-none">使用 Worker 代理 (解决 CORS/相对路径)</label>
                        </div>

                        <!-- 按钮组 -->
                        <div class="flex gap-2">
                            <button 
                                id="load-playlist" 
                                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200"
                            >
                                加载 M3U 列表
                            </button>
                            <button 
                                id="direct-play" 
                                class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200"
                            >
                                直链播放
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-3 text-sm h-5">
                    <span id="status-message" class="text-yellow-500">等待输入...</span>
                </div>
            </header>

            <!-- 视频播放器 -->
            <div class="flex-grow bg-[#161b22] rounded-lg p-1.5 shadow-xl relative min-h-[300px]">
                <video 
                    id="tv-player" 
                    class="video-js vjs-default-skin w-full h-full rounded-md" 
                    controls 
                    preload="auto" 
                    poster="https://placehold.co/1280x720/161b22/c9d1d9?text=IPTV+Stream"
                >
                    <p class="vjs-no-js">
                        要查看此视频，请启用 JavaScript，并考虑升级到支持 HTML5 视频的浏览器。
                    </p>
                </video>
            </div>
        </section>
    </div>

    <!-- JavaScript Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const iptvUrlInput = document.getElementById('iptv-url');
            const loadButton = document.getElementById('load-playlist');
            const directPlayButton = document.getElementById('direct-play'); // 直链播放按钮
            const useProxyCheckbox = document.getElementById('use-proxy'); // Worker 开关
            const channelListUl = document.getElementById('channels');
            const statusMessage = document.getElementById('status-message');
            const videoElement = document.getElementById('tv-player');
            
            // 初始化 Video.js 播放器
            const player = videojs(videoElement, {
                 autoplay: true,
                 muted: true, // 初始静音以规避浏览器自动播放限制
                 controls: true,
            });

            // ==========================================================
            // !!! 关键配置: Cloudflare Worker 代理地址 !!!
            // ==========================================================
            // 确保这里是您的 Worker 的 HTTPS 地址，末尾包含斜杠 "/"。
            const WORKER_PROXY_BASE_URL = 'https://m3u.521986.xyz/'; 

            /**
             * 更新状态信息
             */
            function updateStatus(message, type = 'info') {
                statusMessage.textContent = message;
                statusMessage.style.color = {
                    'info': '#fcd34d', 
                    'error': '#f87171', 
                    'success': '#4ade80' 
                }[type] || '#fcd34d';
            }

            /**
             * 检查是否启用 Worker 代理
             */
            function isProxyEnabled() {
                return useProxyCheckbox.checked;
            }

            /**
             * ⭐ 核心修复：清理用户输入的 URL，防止双重代理 ⭐
             */
/**
 * ⭐ 核心修复：清理用户输入的 URL，防止双重代理 ⭐
 */
// Worker 脚本 - 解决 CORS, HLS 相对路径, 并增强 Header 兼容性
// ⭐ 关键修复: 彻底解决递归代理、Mixed Content和双重代理问题

// 辅助函数：确保所有响应都包含 CORS 头部
function addCORSHeaders(response) {
    const newResponse = new Response(response.body, response);
    newResponse.headers.set('Access-Control-Allow-Origin', '*');
    newResponse.headers.set('Access-Control-Allow-Methods', 'GET, HEAD, POST, OPTIONS');
    newResponse.headers.set('Access-Control-Allow-Headers', '*');
    newResponse.headers.set('Access-Control-Max-Age', '86400');
    return newResponse;
}

// 辅助函数：自动将 HTTP 转换为 HTTPS
function ensureHTTPS(url) {
    try {
        const urlObj = new URL(url);
        if (urlObj.protocol === 'http:') {
            urlObj.protocol = 'https:';
            return urlObj.toString();
        }
    } catch (e) {
        // URL解析失败，保持原样
    }
    return url;
}

// 辅助函数：检查是否为递归代理链接（增强版）
function isRecursiveProxyLink(link, workerBase) {
    if (!link) return false;
    
    // 检查是否包含代理模式
    const proxyPatterns = [
        '/?url=', '?url=', '%2F%3Furl%3D', '%3Furl%3D',
        'worker.dev', 'pages.dev', 'm3u.521986.xyz'
    ];
    
    return proxyPatterns.some(pattern => link.includes(pattern));
}

// 辅助函数：从递归链接中提取原始URL（增强版）
function extractOriginalUrl(recursiveUrl, workerBase) {
    try {
        let currentUrl = recursiveUrl;
        let depth = 0;
        const maxDepth = 5; // 防止无限循环
        
        while (depth < maxDepth) {
            try {
                const urlObj = new URL(currentUrl);
                
                // 如果当前URL不是代理格式，返回它
                if (!urlObj.searchParams.has('url')) {
                    return ensureHTTPS(currentUrl);
                }
                
                const extractedUrl = urlObj.searchParams.get('url');
                if (!extractedUrl) break;
                
                // 解码URL
                currentUrl = decodeURIComponent(extractedUrl);
                depth++;
                
            } catch (e) {
                // 不是有效URL，返回确保HTTPS的版本
                return ensureHTTPS(currentUrl);
            }
        }
        
        return ensureHTTPS(currentUrl);
        
    } catch (e) {
        return ensureHTTPS(recursiveUrl);
    }
}

// 辅助函数：将 M3U/M3U8 中的链接重写为指向 Worker 代理的链接
function rewriteLink(link, workerBase, targetUrl) {
    // 1. 跳过空行和注释
    if (!link || link.startsWith('#') || link.trim() === '') {
        return link;
    }
    
    // 2. ⭐ 关键修复: 检查是否为递归代理链接 ⭐
    if (isRecursiveProxyLink(link, workerBase)) {
        // 如果是递归链接，尝试提取原始URL
        const originalUrl = extractOriginalUrl(link, workerBase);
        return ensureHTTPS(originalUrl);
    }
    
    // 3. 检查链接是否为媒体文件（TS、MP4等），不重写非M3U8链接
    const mediaExtensions = ['.ts', '.mp4', '.m4s', '.aac', '.mp3', '.webm', '.mkv'];
    const isMediaFile = mediaExtensions.some(ext => 
        link.toLowerCase().includes(ext) && !link.toLowerCase().includes('.m3u8')
    );
    
    if (isMediaFile) {
        return ensureHTTPS(link); // 不重写媒体文件链接，但确保HTTPS
    }
    
    // 4. 尝试将链接解析为绝对 URL
    let absoluteUrl = link;
    try {
        const base = targetUrl.substring(0, targetUrl.lastIndexOf('/') + 1);
        absoluteUrl = new URL(link, base).toString();
    } catch (e) {
        // 保持原样，但确保HTTPS
        return ensureHTTPS(link);
    }
    
    // 5. 再次检查是否为递归链接（转换后）
    if (isRecursiveProxyLink(absoluteUrl, workerBase)) {
        const originalUrl = extractOriginalUrl(absoluteUrl, workerBase);
        return ensureHTTPS(originalUrl);
    }
    
    // 6. 只重写M3U8相关的链接
    const isM3U8Link = absoluteUrl.includes('.m3u8') || absoluteUrl.includes('.m3u');
    if (!isM3U8Link) {
        return ensureHTTPS(absoluteUrl); // 不重写非M3U8链接，但确保HTTPS
    }
    
    // 7. 重写为 Worker 代理链接（确保使用HTTPS）
    const secureUrl = ensureHTTPS(absoluteUrl);
    const newLink = `${workerBase}?url=${encodeURIComponent(secureUrl)}`;
    return newLink;
}

addEventListener('fetch', event => {
    event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
    // 处理 CORS Preflight (OPTIONS) 请求
    if (request.method === 'OPTIONS') {
        return addCORSHeaders(new Response(null, { status: 200 }));
    }
    
    const url = new URL(request.url);
    let targetUrl = url.searchParams.get('url');
    
    // 使用请求的 URL origin 作为 Worker 代理的基地址
    const WORKER_PROXY_BASE_URL = url.origin + '/';

    if (!targetUrl) {
        const errorResponse = new Response('错误: 请提供 M3U 订阅链接或流地址作为 "url" 参数。', { 
            status: 400,
            headers: { 'Content-Type': 'text/plain; charset=utf-8' }
        });
        return addCORSHeaders(errorResponse);
    }

    // ⭐ 关键修复: 自动将目标 URL 的 HTTP 转换为 HTTPS ⭐
    targetUrl = ensureHTTPS(targetUrl);
    
    // 清理请求头部
    const headers = new Headers();
    headers.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
    headers.set('Accept', '*/*');
    headers.set('Accept-Language', 'en-US,en;q=0.5');
    
    // 添加 Referer 和 Origin 头
    try {
        const targetUrlObj = new URL(targetUrl);
        headers.set('Referer', targetUrlObj.origin);
        headers.set('Origin', targetUrlObj.origin);
    } catch (e) {
        // 忽略URL解析错误
    }

    try {
        // 核心代理请求
        const response = await fetch(targetUrl, {
            method: 'GET',
            headers: headers,
            redirect: 'follow'
        });

        const responseContentType = response.headers.get('content-type') || '';
        
        // 检查内容是否为 M3U/M3U8（只处理文本类型的M3U8文件）
        const isM3U8Content = (responseContentType.includes('application/vnd.apple.mpegurl') || 
                              responseContentType.includes('application/x-mpegURL') || 
                              responseContentType.includes('audio/mpegurl')) &&
                              !responseContentType.includes('video') &&
                              !responseContentType.includes('audio');
        
        const isM3U8Extension = targetUrl.includes('.m3u8') || targetUrl.includes('.m3u');
        const isSmallTextFile = response.headers.get('Content-Length') < 100000 && // 增大文件大小限制
                               (responseContentType.includes('text/plain') || 
                                responseContentType.includes('application/'));

        if ((isM3U8Content || isM3U8Extension) && isSmallTextFile) {
            // 如果 M3U8 索引文件本身获取失败，直接返回错误状态
            if (!response.ok) {
                const errorResponse = new Response(`上游服务器错误: ${response.status} ${response.statusText}`, {
                    status: response.status,
                    headers: { 'Content-Type': 'text/plain; charset=utf-8' }
                });
                return addCORSHeaders(errorResponse);
            }

            // 获取文本内容
            const text = await response.text();
            
            // 使用 rewriteLink 辅助函数重写所有非注释行中的链接
            const rewrittenText = text.split('\n').map(line => {
                const trimmedLine = line.trim();
                if (trimmedLine && !trimmedLine.startsWith('#')) {
                    return rewriteLink(trimmedLine, WORKER_PROXY_BASE_URL, targetUrl);
                }
                return line;
            }).join('\n');
            
            // 创建重写后的响应
            const newResponse = new Response(rewrittenText, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers
            });

            // 设置正确的 MIME 类型
            newResponse.headers.set('Content-Type', 'application/vnd.apple.mpegurl');
            
            // 添加 CORS 头部并返回
            return addCORSHeaders(newResponse);

        } else {
            // 处理媒体文件和其他内容（MP4、TS等）
            const newHeaders = new Headers(response.headers);
            newHeaders.set('Cache-Control', 'no-cache, no-store, must-revalidate');
            
            const newResponse = new Response(response.body, {
                status: response.status,
                statusText: response.statusText,
                headers: newHeaders
            });
            
            return addCORSHeaders(newResponse);
        }

    } catch (e) {
        // 代理请求失败
        const errorBody = `代理请求失败: ${e.message || '网络错误'}`;
        return addCORSHeaders(new Response(errorBody, {
            status: 500,
            headers: { 'Content-Type': 'text/plain; charset=utf-8' }
        }));
    }
}

            /**
             * 将原始 URL 转换为 Worker 代理 URL 或返回原始 URL (取决于开关)
             */
            function getProcessedUrl(url) {
                if (isProxyEnabled() && WORKER_PROXY_BASE_URL) {
                    // 对 M3U/M3U8 链接进行编码，然后通过 Worker 代理
                    return `${WORKER_PROXY_BASE_URL}?url=${encodeURIComponent(url)}`;
                }
                // 返回原始链接 (直链或 Worker 禁用)
                return url;
            }

            /**
             * 获取 M3U 文件内容 (使用或不使用 Worker 代理)
             */
            async function fetchM3UContent(rawUrl) {
                // 先清理 URL，防止双重代理
                const cleanUrl = cleanInputUrl(rawUrl);
                
                // 根据开关决定最终请求的 URL
                const finalUrl = getProcessedUrl(cleanUrl);
                
                const proxyMessage = isProxyEnabled() ? '通过 Worker 代理' : '直连';
                updateStatus(`正在${proxyMessage}加载 M3U 列表: ${cleanUrl.substring(0, 50)}...`, 'info');

                try {
                    const response = await fetch(finalUrl);

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`网络错误或源站超时: ${response.status} ${response.statusText}. 响应: ${errorText}`);
                    }

                    const text = await response.text();
                    updateStatus('M3U 列表加载成功，正在解析。', 'success');
                    return { content: text, baseUrl: cleanUrl }; // 返回原始 M3U 链接作为解析相对路径的基准

                } catch (error) {
                    if (error.message.includes('522') && isProxyEnabled()) {
                         updateStatus('错误 (522): Worker 递归调用或连接超时。请尝试关闭 Worker 代理。', 'error');
                    } else if (error.message.includes('CORS')) {
                         updateStatus('错误 (CORS): 无法获取 M3U 内容。请尝试开启 Worker 代理。', 'error');
                    } else {
                         updateStatus(`加载 M3U 失败: ${error.message}`, 'error');
                    }
                    console.error('Fetch M3U Error:', error);
                    return null;
                }
            }

            /**
             * 解析 M3U 文件内容
             */
            function parseM3U(content) {
                // ... (解析逻辑不变)
                const lines = content.split('\n');
                const channels = [];
                let currentChannel = {};

                for (const line of lines) {
                    if (line.startsWith('#EXTINF:')) {
                        const match = line.match(/,(.+)$/);
                        if (match && match[1]) {
                            currentChannel.name = match[1].trim();
                        }
                    } else if (line.trim().length > 0 && !line.startsWith('#')) {
                        currentChannel.url = line.trim();
                        if (currentChannel.name && currentChannel.url) {
                            channels.push({ ...currentChannel });
                        }
                        currentChannel = {}; 
                    }
                }
                return channels;
            }

            /**
             * 渲染频道列表
             */
            function renderChannels(channels) {
                // ... (渲染逻辑不变)
                channelListUl.innerHTML = '';
                channels.forEach((channel, index) => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = channel.name;
                    a.setAttribute('data-url', channel.url);
                    a.setAttribute('data-name', channel.name);
                    a.onclick = (e) => {
                        e.preventDefault();
                        playChannel(channel.url, channel.name, index);
                        
                        document.querySelectorAll('#channels li a').forEach(el => {
                            el.classList.remove('active');
                        });
                        a.classList.add('active');
                        
                        // 保存当前播放的流的原始 URL (用于恢复会话)
                        localStorage.setItem('currentStreamUrl', channel.url);
                    };
                    li.appendChild(a);
                    li.classList.add('rounded-lg');
                    channelListUl.appendChild(li);
                });
            }

            /**
             * 播放指定的频道 (使用或不使用 Worker 代理)
             */
            function playChannel(rawUrl, name, index) {
                player.pause(); 
                
                // ⭐ 核心：根据 Worker 开关决定播放 URL ⭐
                // 如果启用了 Worker， getProcessedUrl 会返回代理链接，由 Worker 解决 CORS 和相对路径
                // 如果禁用 Worker， getProcessedUrl 会返回原始链接
                const url = getProcessedUrl(rawUrl); 

                const proxyStatus = isProxyEnabled() ? ' (通过 Worker)' : ' (直连)';
                updateStatus(`频道播放中: ${name}${proxyStatus}`, 'success');

                // Hls.js 播放逻辑 (推荐使用 Hls.js 以获取更好的兼容性)
                if (Hls.isSupported()) {
                    // 必须先销毁旧的 Hls.js 实例
                    if (player.hls) {
                        player.hls.destroy();
                    }
                    
                    const hls = new Hls();
                    player.hls = hls; // 存储实例以便后续销毁
                    
                    hls.loadSource(url);
                    hls.attachMedia(videoElement);

                    hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        player.play().catch(e => {
                            player.muted(false); // 取消静音后重试
                            player.play().catch(err => {
                                console.log("Player autplay blocked:", err);
                                updateStatus(`播放失败: ${name} (需要用户手动点击播放)`, 'error');
                            });
                        });
                    });
                    hls.on(Hls.Events.ERROR, function (event, data) {
                        if (data.fatal) {
                            // ... 错误处理逻辑 (不变)
                            updateStatus(`播放错误: ${name}. ${data.reason} (${isProxyEnabled() ? 'Proxy On' : 'Proxy Off'})`, 'error');
                        }
                    });
                } 
                // Video.js 原生/浏览器原生 HLS 逻辑 (适用于 Safari/Edge)
                else if (videoElement.canPlayType('application/vnd.apple.mpegurl') || videoElement.canPlayType('application/x-mpegURL')) {
                    player.src({
                        src: url,
                        type: 'application/x-mpegURL'
                    });
                    player.load();
                    player.play().catch(e => console.log("Player autplay blocked:", e));
                } 
                // 都不支持
                else {
                    updateStatus('错误: 您的浏览器不支持 HLS/M3U8 流播放。', 'error');
                }
            }

            // ==========================================================
            // 事件监听器
            // ==========================================================

            // 1. 加载 M3U 列表
            loadButton.addEventListener('click', async () => {
                const m3uInput = iptvUrlInput.value.trim();
                if (!m3uInput) {
                    updateStatus('请输入 M3U 订阅链接！', 'error');
                    return;
                }

                // 保存用户输入的 URL (清理后的)
                const m3uUrl = cleanInputUrl(m3uInput);
                localStorage.setItem('iptvUrl', m3uUrl);
                localStorage.removeItem('currentStreamUrl'); // 清除直链模式记录
                localStorage.setItem('useProxy', isProxyEnabled()); // 记录代理开关状态

                const m3uResult = await fetchM3UContent(m3uUrl);
                
                if (m3uResult) {
                    const channels = parseM3U(m3uResult.content);
                    renderChannels(channels);
                    
                    if (channels.length > 0) {
                        // 默认播放第一个频道
                        setTimeout(() => {
                            document.querySelector('#channels li a')?.click();
                        }, 50); 
                    } else {
                         updateStatus('M3U 文件已加载，但未找到任何频道。', 'error');
                    }
                }
            });

            // 2. 直链播放
            directPlayButton.addEventListener('click', () => {
                const streamUrl = iptvUrlInput.value.trim();
                if (!streamUrl) {
                    updateStatus('请输入有效的流地址进行直链播放！', 'error');
                    return;
                }
                
                // 清空频道列表
                channelListUl.innerHTML = `<p class="p-2 text-gray-500">当前为直链播放模式。</p>`;
                
                // 保存当前直链 URL 和代理状态
                localStorage.setItem('iptvUrl', streamUrl); // 统一使用 iptvUrl 存储上次使用的 URL
                localStorage.setItem('currentStreamUrl', streamUrl); // 记录当前播放的流
                localStorage.setItem('useProxy', isProxyEnabled()); // 记录代理开关状态

                const streamName = `直链流 (${streamUrl.substring(0, 40)}...)`;

                playChannel(streamUrl, streamName);
            });
            
            // 3. 初始加载逻辑
            const storedUrl = localStorage.getItem('iptvUrl');
            const storedStreamUrl = localStorage.getItem('currentStreamUrl');
            const storedProxy = localStorage.getItem('useProxy') === 'true';

            // 恢复代理开关状态
            useProxyCheckbox.checked = storedProxy;

            if (storedUrl) {
                iptvUrlInput.value = storedUrl;
                updateStatus('检测到上次会话记录，正在加载...', 'info');
                
                // 检查是 M3U 列表模式还是直链模式
                if (storedStreamUrl && storedUrl === storedStreamUrl) {
                    // 如果上次是直链播放，恢复直链模式
                    directPlayButton.click();
                } else {
                    // 如果上次是 M3U 列表模式，恢复 M3U 列表模式
                    loadButton.click(); 
                }
            } else {
                 updateStatus('请输入 M3U 订阅链接或流地址。', 'info');
            }
        });
    </script>
</body>
</html>




